"""
Compton Scattering Extension - Output Wave Emission

This module extends the photoelectric model to include wave emission,
enabling investigation of Compton-like scattering behavior through
pure wave mechanics.

In Compton scattering:
- Incoming photon scatters off electron
- Outgoing photon has lower frequency (wavelength shift)
- The shift depends on scattering angle

Wave interpretation:
- Incoming wave drives the internal store
- Electron motion + store state generates an OUTPUT wave
- The output wave frequency is modified by the internal dynamics
- This could produce Compton-like wavelength shifts

The key addition is an output wave function:
    u_out(t) = g(x, v, s, f_in)

where the output depends on:
- Electron position x and velocity v
- Internal store s
- Input frequency f_in

The output wave frequency emerges from the motion dynamics.
"""

import numpy as np
import logging
from typing import Tuple, Optional, Dict
from dataclasses import dataclass

from .physics import AtomModel, EscapeDetector
from .integrator import RK4Integrator

logger = logging.getLogger(__name__)


@dataclass
class ComptonResult:
    """Results from a Compton scattering simulation."""
    
    # Input parameters
    input_frequency: float
    input_amplitude: float
    
    # Output wave characteristics
    output_amplitude: float
    output_frequency: float  # Dominant frequency in output
    frequency_shift: float   # f_out - f_in
    wavelength_shift_ratio: float  # (lambda_out - lambda_in) / lambda_in
    
    # Time series
    times: np.ndarray
    input_wave: np.ndarray
    output_wave: np.ndarray
    positions: np.ndarray
    velocities: np.ndarray
    stores: np.ndarray
    
    # Scattering metrics
    energy_ratio: float  # Output/Input energy
    phase_shift: float   # Phase difference
    
    def __repr__(self):
        return (
            f"ComptonResult(f_in={self.input_frequency:.3f}, "
            f"f_out={self.output_frequency:.3f}, "
            f"shift={self.frequency_shift:.4f})"
        )


class ComptonAtomModel(AtomModel):
    """
    Extended atom model that produces output radiation.
    
    The output wave is generated by the accelerating electron,
    following classical radiation theory:
    
    Output ∝ acceleration = dv/dt
    
    But we also include modulation by the internal store,
    which can shift the output frequency.
    """
    
    def __init__(
        self,
        omega0: float = 1.0,
        damping: float = 0.0001,
        alpha: float = 0.05,
        beta: float = 100.0,
        amplitude: float = 0.2,
        # Compton-specific parameters
        emission_coupling: float = 1.0,  # How strongly electron radiates
        store_modulation: float = 0.1    # How much store affects output freq
    ):
        """
        Initialize Compton atom model.
        
        Args:
            emission_coupling: Strength of radiation emission
            store_modulation: How much the store modulates output frequency
        """
        super().__init__(omega0, damping, alpha, beta, amplitude)
        self.emission_coupling = emission_coupling
        self.store_modulation = store_modulation
        
        logger.info(
            f"ComptonAtomModel: emission_coupling={emission_coupling}, "
            f"store_modulation={store_modulation}"
        )
    
    def output_wave(
        self, 
        t: float, 
        state: np.ndarray, 
        frequency: float,
        prev_state: Optional[np.ndarray] = None,
        dt: float = 0.001
    ) -> float:
        """
        Calculate the output (scattered) wave amplitude.
        
        The output wave is driven by electron acceleration,
        modulated by the internal store state.
        
        Classical picture: accelerating charge radiates
        u_out ∝ d²x/dt² = dv/dt
        
        Store modulation: the internal state affects the
        "effective resonance" of the atom, shifting output frequency
        
        Args:
            t: Current time
            state: Current state [x, v, s]
            frequency: Input wave frequency
            prev_state: Previous state (for acceleration calc)
            dt: Time step
            
        Returns:
            Output wave amplitude at time t
        """
        x, v, s = state
        
        # Calculate acceleration (radiation source)
        if prev_state is not None:
            _, v_prev, _ = prev_state
            acceleration = (v - v_prev) / dt
        else:
            # Approximate from equations of motion
            u = self.wave_input(t, frequency)
            acceleration = -self.omega0_sq * x - self.damping * v + s * u
        
        # Base output: proportional to acceleration
        output = self.emission_coupling * acceleration
        
        # Store modulation: shifts effective frequency
        # When s is large, the "resonance" shifts
        # This creates a frequency-dependent phase shift
        phase_mod = self.store_modulation * s * np.sin(2 * np.pi * frequency * t)
        output += phase_mod
        
        return output
    
    def output_wave_complex(
        self, 
        t: float, 
        state: np.ndarray, 
        frequency: float
    ) -> complex:
        """
        Calculate complex output wave (for frequency analysis).
        
        Returns complex amplitude for FFT analysis.
        """
        x, v, s = state
        u = self.wave_input(t, frequency)
        
        # Acceleration-based output
        accel = -self.omega0_sq * x - self.damping * v + s * u
        
        # Complex representation for frequency analysis
        real_part = self.emission_coupling * accel
        imag_part = self.store_modulation * s * v
        
        return complex(real_part, imag_part)


class ComptonSimulation:
    """
    Simulation of Compton-like scattering in the wave model.
    
    Runs the extended model and analyzes both input and output waves
    to determine frequency shifts and scattering characteristics.
    """
    
    def __init__(
        self,
        atom: ComptonAtomModel,
        t_max: float = 100.0,
        dt: float = 0.0005
    ):
        """
        Initialize Compton simulation.
        
        Args:
            atom: ComptonAtomModel instance
            t_max: Maximum simulation time
            dt: Integration time step
        """
        self.atom = atom
        self.t_max = t_max
        self.dt = dt
        self.integrator = RK4Integrator(dt=dt)
        
        logger.info(f"ComptonSimulation initialized: t_max={t_max}, dt={dt}")
    
    def run(self, frequency: float) -> ComptonResult:
        """
        Run a Compton scattering simulation.
        
        Args:
            frequency: Input wave frequency
            
        Returns:
            ComptonResult with input/output wave analysis
        """
        logger.info(f"Running Compton simulation at f={frequency:.4f}")
        
        # Initial conditions
        y = np.array([0.05, 0.0, 0.0])  # [x, v, s]
        t = 0.0
        
        # Storage
        n_steps = int(self.t_max / self.dt)
        store_every = 10
        n_stored = n_steps // store_every + 1
        
        times = np.zeros(n_stored)
        input_waves = np.zeros(n_stored)
        output_waves = np.zeros(n_stored)
        positions = np.zeros(n_stored)
        velocities = np.zeros(n_stored)
        stores = np.zeros(n_stored)
        
        # Initial values
        times[0] = t
        input_waves[0] = self.atom.wave_input(t, frequency)
        output_waves[0] = 0.0
        positions[0], velocities[0], stores[0] = y
        
        prev_y = y.copy()
        store_idx = 1
        
        # Integration loop
        for step in range(n_steps):
            # Advance state
            t, y = self.integrator.step(t, y, self.atom.derivatives, frequency)
            
            # Store periodically
            if step % store_every == 0 and store_idx < n_stored:
                times[store_idx] = t
                input_waves[store_idx] = self.atom.wave_input(t, frequency)
                output_waves[store_idx] = self.atom.output_wave(
                    t, y, frequency, prev_y, self.dt * store_every
                )
                positions[store_idx] = y[0]
                velocities[store_idx] = y[1]
                stores[store_idx] = y[2]
                store_idx += 1
            
            prev_y = y.copy()
            
            # Check for numerical instability
            if np.any(np.isnan(y)) or np.any(np.abs(y) > 1e6):
                logger.warning(f"Numerical instability at t={t:.2f}")
                break
        
        # Trim arrays
        times = times[:store_idx]
        input_waves = input_waves[:store_idx]
        output_waves = output_waves[:store_idx]
        positions = positions[:store_idx]
        velocities = velocities[:store_idx]
        stores = stores[:store_idx]
        
        # Analyze output frequency using FFT
        output_freq, output_amp, phase_shift = self._analyze_frequency(
            times, output_waves, frequency
        )
        
        # Calculate metrics
        input_energy = np.mean(input_waves ** 2)
        output_energy = np.mean(output_waves ** 2)
        energy_ratio = output_energy / input_energy if input_energy > 0 else 0
        
        frequency_shift = output_freq - frequency
        
        # Wavelength shift ratio (λ_out - λ_in) / λ_in = f_in/f_out - 1
        if output_freq > 0:
            wavelength_shift_ratio = frequency / output_freq - 1
        else:
            wavelength_shift_ratio = 0
        
        logger.info(
            f"Compton result: f_in={frequency:.4f}, f_out={output_freq:.4f}, "
            f"shift={frequency_shift:.4f}"
        )
        
        return ComptonResult(
            input_frequency=frequency,
            input_amplitude=self.atom.amplitude,
            output_amplitude=output_amp,
            output_frequency=output_freq,
            frequency_shift=frequency_shift,
            wavelength_shift_ratio=wavelength_shift_ratio,
            times=times,
            input_wave=input_waves,
            output_wave=output_waves,
            positions=positions,
            velocities=velocities,
            stores=stores,
            energy_ratio=energy_ratio,
            phase_shift=phase_shift
        )
    
    def _analyze_frequency(
        self, 
        times: np.ndarray, 
        signal: np.ndarray,
        expected_freq: float
    ) -> Tuple[float, float, float]:
        """
        Analyze dominant frequency in signal using FFT.
        
        Args:
            times: Time array
            signal: Signal to analyze
            expected_freq: Expected input frequency
            
        Returns:
            Tuple of (dominant_frequency, amplitude, phase_shift)
        """
        if len(signal) < 10:
            return expected_freq, 0.0, 0.0
        
        # Remove mean
        signal_centered = signal - np.mean(signal)
        
        # FFT
        n = len(signal_centered)
        dt = times[1] - times[0] if len(times) > 1 else self.dt
        
        fft = np.fft.rfft(signal_centered)
        freqs = np.fft.rfftfreq(n, dt)
        
        # Find dominant frequency (excluding DC)
        amplitudes = np.abs(fft)
        if len(amplitudes) > 1:
            amplitudes[0] = 0  # Exclude DC
            peak_idx = np.argmax(amplitudes)
            dominant_freq = freqs[peak_idx]
            dominant_amp = amplitudes[peak_idx] * 2 / n
            
            # Phase at dominant frequency
            phase = np.angle(fft[peak_idx])
        else:
            dominant_freq = expected_freq
            dominant_amp = 0.0
            phase = 0.0
        
        return dominant_freq, dominant_amp, phase
    
    def run_frequency_sweep(
        self, 
        frequencies: np.ndarray
    ) -> Dict[float, ComptonResult]:
        """
        Run Compton simulation across multiple input frequencies.
        
        Args:
            frequencies: Array of input frequencies
            
        Returns:
            Dictionary mapping frequency to ComptonResult
        """
        results = {}
        
        logger.info(f"Running Compton frequency sweep: {len(frequencies)} frequencies")
        
        for f in frequencies:
            result = self.run(f)
            results[f] = result
        
        return results


def analyze_compton_shift(results: Dict[float, ComptonResult]) -> Dict:
    """
    Analyze Compton-like wavelength shifts across frequencies.
    
    In real Compton scattering:
    Δλ = (h/mc)(1 - cos θ) = λ_C(1 - cos θ)
    
    where λ_C is the Compton wavelength.
    
    We look for systematic frequency/wavelength shifts in our model.
    
    Args:
        results: Dictionary of ComptonResult by input frequency
        
    Returns:
        Analysis dictionary with shift statistics
    """
    input_freqs = []
    output_freqs = []
    shifts = []
    wavelength_shifts = []
    
    for f_in, result in results.items():
        input_freqs.append(f_in)
        output_freqs.append(result.output_frequency)
        shifts.append(result.frequency_shift)
        wavelength_shifts.append(result.wavelength_shift_ratio)
    
    input_freqs = np.array(input_freqs)
    output_freqs = np.array(output_freqs)
    shifts = np.array(shifts)
    wavelength_shifts = np.array(wavelength_shifts)
    
    # Analyze trends
    analysis = {
        'input_frequencies': input_freqs,
        'output_frequencies': output_freqs,
        'frequency_shifts': shifts,
        'wavelength_shifts': wavelength_shifts,
        'mean_shift': np.mean(shifts),
        'mean_wavelength_shift': np.mean(wavelength_shifts),
        'shift_increases_with_freq': np.corrcoef(input_freqs, shifts)[0, 1] > 0
    }
    
    # Check if shifts follow Compton-like pattern
    # In Compton: Δλ is constant (for fixed angle), so Δf ∝ -f²
    if len(input_freqs) > 2:
        # Fit: shift = a * f_in + b
        try:
            coeffs = np.polyfit(input_freqs, shifts, 1)
            analysis['linear_fit_slope'] = coeffs[0]
            analysis['linear_fit_intercept'] = coeffs[1]
        except:
            pass
    
    logger.info(
        f"Compton analysis: mean shift = {analysis['mean_shift']:.4f}, "
        f"mean wavelength shift = {analysis['mean_wavelength_shift']:.4f}"
    )
    
    return analysis


def plot_compton_results(
    results: Dict[float, ComptonResult],
    analysis: Dict,
    save_path: Optional[str] = None,
    show: bool = True
):
    """
    Visualize Compton scattering results.
    
    Creates plots showing:
    - Input vs output frequency
    - Frequency shift vs input frequency
    - Example input/output waveforms
    """
    import matplotlib.pyplot as plt
    
    fig, axes = plt.subplots(2, 2, figsize=(14, 10))
    
    input_freqs = analysis['input_frequencies']
    output_freqs = analysis['output_frequencies']
    shifts = analysis['frequency_shifts']
    
    # 1. Input vs Output frequency
    ax1 = axes[0, 0]
    ax1.scatter(input_freqs, output_freqs, c='blue', s=80, edgecolor='white')
    ax1.plot([min(input_freqs), max(input_freqs)], 
             [min(input_freqs), max(input_freqs)], 
             'k--', alpha=0.5, label='f_out = f_in (no shift)')
    ax1.set_xlabel('Input Frequency')
    ax1.set_ylabel('Output Frequency')
    ax1.set_title('Compton-like Scattering: Input vs Output Frequency')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2. Frequency shift vs input frequency
    ax2 = axes[0, 1]
    ax2.scatter(input_freqs, shifts, c='red', s=80, edgecolor='white')
    ax2.axhline(y=0, color='gray', linestyle='--', alpha=0.5)
    ax2.axhline(y=analysis['mean_shift'], color='blue', linestyle='-', 
                label=f'Mean shift = {analysis["mean_shift"]:.4f}')
    ax2.set_xlabel('Input Frequency')
    ax2.set_ylabel('Frequency Shift (f_out - f_in)')
    ax2.set_title('Frequency Shift vs Input Frequency')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # 3. Example waveforms (pick middle frequency)
    ax3 = axes[1, 0]
    mid_freq = input_freqs[len(input_freqs) // 2]
    result = results[mid_freq]
    
    # Plot subset of time series
    n_plot = min(500, len(result.times))
    ax3.plot(result.times[:n_plot], result.input_wave[:n_plot], 
             'b-', alpha=0.7, label='Input wave')
    ax3.plot(result.times[:n_plot], result.output_wave[:n_plot], 
             'r-', alpha=0.7, label='Output wave')
    ax3.set_xlabel('Time')
    ax3.set_ylabel('Amplitude')
    ax3.set_title(f'Input/Output Waves at f = {mid_freq:.3f}')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    # 4. Store and position dynamics
    ax4 = axes[1, 1]
    ax4.plot(result.times[:n_plot], result.positions[:n_plot], 
             'g-', alpha=0.7, label='Position x')
    ax4_twin = ax4.twinx()
    ax4_twin.plot(result.times[:n_plot], result.stores[:n_plot], 
                  'orange', alpha=0.7, label='Store s')
    ax4.set_xlabel('Time')
    ax4.set_ylabel('Position x', color='green')
    ax4_twin.set_ylabel('Store s', color='orange')
    ax4.set_title('Electron Dynamics During Scattering')
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        logger.info(f"Saved Compton plot to {save_path}")
    
    if show:
        plt.show()
    
    return fig


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def run_compton_experiment(
    frequencies: np.ndarray = None,
    show_plots: bool = True,
    save_path: Optional[str] = None
) -> Tuple[Dict[float, ComptonResult], Dict]:
    """
    Run a complete Compton scattering experiment.
    
    Args:
        frequencies: Input frequencies to test (default: 0.1 to 0.5)
        show_plots: Whether to display plots
        save_path: Optional path to save results
        
    Returns:
        Tuple of (results_dict, analysis_dict)
    """
    if frequencies is None:
        frequencies = np.linspace(0.1, 0.5, 10)
    
    logger.info("=" * 60)
    logger.info("COMPTON SCATTERING EXPERIMENT")
    logger.info("=" * 60)
    
    # Create Compton model
    atom = ComptonAtomModel(
        omega0=1.0,
        damping=0.0001,
        alpha=0.05,
        beta=100.0,
        amplitude=0.2,
        emission_coupling=1.0,
        store_modulation=0.2
    )
    
    sim = ComptonSimulation(atom, t_max=50.0, dt=0.0005)
    
    # Run sweep
    results = sim.run_frequency_sweep(frequencies)
    
    # Analyze
    analysis = analyze_compton_shift(results)
    
    # Report
    logger.info("")
    logger.info("COMPTON ANALYSIS RESULTS:")
    logger.info(f"  Mean frequency shift: {analysis['mean_shift']:.4f}")
    logger.info(f"  Mean wavelength shift: {analysis['mean_wavelength_shift']:.4f}")
    
    if show_plots:
        plot_compton_results(results, analysis, save_path=save_path, show=True)
    
    return results, analysis

